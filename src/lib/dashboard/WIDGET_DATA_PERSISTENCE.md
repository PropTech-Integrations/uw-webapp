# Widget Data Persistence Guide

## Overview

The dashboard now **automatically saves and restores widget data** from the mapObjectStore when saving to local storage. This means AI-generated content, user inputs, and any dynamic widget data persists across browser sessions.

---

## What Gets Saved?

### Before (Version 1.0.0)
```json
{
  "widgets": [
    {
      "id": "widget-1",
      "type": "paragraph",
      "data": {
        "title": "Static Title",
        "content": "Static content from code"
      }
    }
  ],
  "config": { ... }
}
```

**Problem:** Only static widget configuration was saved, not dynamic data from mapObjectStore.

### After (Version 2.0.0)
```json
{
  "widgets": [
    {
      "id": "widget-1",
      "type": "paragraph",
      "data": {
        "title": "Static Title",
        "content": "Static content"
      }
    }
  ],
  "config": { ... },
  "widgetData": {
    "paragraph-content": {
      "title": "AI Generated Title",
      "content": "This was generated by AI and persists!",
      "markdown": true
    },
    "table-data": {
      "headers": ["Name", "Value"],
      "rows": [...]
    }
  }
}
```

**Solution:** Widget data from all mapObjectStore channels is now saved and restored!

---

## How It Works

### Save Flow

```
User clicks "Save" or auto-save triggers
         ↓
dashboard.save() called
         ↓
DashboardStorage.saveDashboard()
         ↓
mapStore.getAllData() ← Captures all channel data
         ↓
Creates widgetData snapshot:
{
  "paragraph-content": {...},
  "table-data": {...},
  "metric-data": {...}
}
         ↓
Saves to localStorage:
- WIDGETS (widget configuration)
- CONFIG (grid configuration)
- WIDGET_DATA (mapObjectStore data) ← NEW!
- VERSION (2.0.0)
```

### Load Flow

```
User opens dashboard
         ↓
dashboard.initialize() called
         ↓
DashboardStorage.loadDashboard()
         ↓
Reads from localStorage:
- widgets
- config
- widgetData ← NEW!
         ↓
restoreWidgetData() called
         ↓
For each channel in widgetData:
  1. Create temporary producer
  2. Publish data to mapObjectStore
  3. Unregister temporary producer
         ↓
Widgets subscribe and receive restored data
         ↓
Dashboard displays with saved content!
```

---

## Example Scenario

### 1. User Submits AI Job

```
User clicks "Submit Job"
         ↓
AI generates paragraph content
         ↓
Bridge publishes to mapObjectStore:
  Channel: paragraph-content
  Data: { title: "AI Summary", content: "..." }
         ↓
ParagraphWidget displays AI content
```

### 2. User Saves Dashboard

```
User clicks "Save" (or auto-save)
         ↓
DashboardStorage captures:
  - Widget configurations
  - mapObjectStore data ← AI content captured!
         ↓
Saved to localStorage
```

### 3. User Refreshes Page

```
Page loads
         ↓
Dashboard initializes
         ↓
Restores mapObjectStore data
         ↓
ParagraphWidget receives AI content again
         ↓
AI-generated content is still there! 🎉
```

---

## Console Output

### When Saving:

```
💾 [DashboardStorage] Saving dashboard to localStorage...
   ✅ Captured data for channel: paragraph-content
   ✅ Captured data for channel: table-data
   ✅ Captured data for channel: metric-data
   Total channels saved: 3
✅ [DashboardStorage] Dashboard saved successfully
```

### When Loading:

```
📂 [DashboardStorage] Loading dashboard from localStorage...
   ✅ Loaded 8 widgets
   ✅ Loaded 3 widget data channels

📤 [DashboardStorage] Restoring widget data to mapObjectStore...
   ✅ Restored data for channel: paragraph-content
   ✅ Restored data for channel: table-data
   ✅ Restored data for channel: metric-data
✅ [DashboardStorage] Widget data restoration complete
```

### When Clearing:

```
🧹 [DashboardStore] Clearing saved dashboard...
   Clearing mapObjectStore data...
✅ [DashboardStore] Dashboard and widget data cleared from localStorage
```

---

## What Data is Saved?

All data currently in the mapObjectStore channels:

| Channel | Data Saved | Example |
|---------|------------|---------|
| `paragraph-content` | AI-generated paragraphs | `{title, content, markdown}` |
| `table-data` | Table rows and headers | `{headers, rows}` |
| `metric-data` | Metric values | `{label, value, change}` |
| `chart-data` | Chart datasets | `{datasets, labels}` |
| Custom channels | Any custom data | Whatever you publish |

**Only channels with data are saved** (undefined values are skipped).

---

## Version Upgrade

### Version Change: 1.0.0 → 2.0.0

The storage version was bumped to `2.0.0` because the data structure changed to include `widgetData`.

**What happens to old saved dashboards?**

```
User has dashboard saved with v1.0.0
         ↓
Loads page
         ↓
Version mismatch detected
         ↓
Old data is cleared (v1.0.0 incompatible)
         ↓
User gets fresh dashboard
```

**Why clear old data?**
- v1.0.0 doesn't have `widgetData` field
- Prevents errors from incompatible structure
- Clean slate for new version

---

## Using the Feature

### Automatic (No Code Changes Needed)

If you're already using:
- `createWidgetConsumer()` in widgets
- `createJobWidgetBridge()` or `createWidgetPublisher()` for data
- Dashboard save functionality

**It just works!** Widget data is automatically saved and restored.

### Manual Data Snapshot

```typescript
import { mapStore } from '$lib/stores/mapObjectStore';

// Get current snapshot
const snapshot = mapStore.getAllData();

// Save manually
localStorage.setItem('my-widget-data', JSON.stringify(snapshot));

// Restore manually
const saved = JSON.parse(localStorage.getItem('my-widget-data'));
saved.forEach(item => {
  const producer = mapStore.registerProducer(item.typeId, 'restore');
  producer.publish(item.value);
  mapStore.unregister('restore');
});
```

---

## Debugging

### Check What's Being Saved

```typescript
// After saving, check localStorage
const widgetData = localStorage.getItem('dashboard_widget_data');
console.log('Saved widget data:', JSON.parse(widgetData));
```

### Verify Restoration

```typescript
// After loading, check mapStore
import { mapStore } from '$lib/stores/mapObjectStore';

// Use debug panel or:
console.table(mapStore.getAllData());
```

### Console Logs

Enable detailed logging by watching for these log messages:

**On Save:**
- `💾 [DashboardStorage] Saving dashboard to localStorage...`
- `✅ Captured data for channel: ...`

**On Load:**
- `📂 [DashboardStorage] Loading dashboard from localStorage...`
- `✅ Restored data for channel: ...`

---

## Best Practices

### 1. Use Meaningful Channel IDs

```typescript
// Good
WidgetChannels.paragraphContent  // 'paragraph-content'
WidgetChannels.tableData         // 'table-data'

// Bad
'channel1'
'temp-data'
```

Meaningful IDs make it easier to debug what's saved.

### 2. Validate Data on Restore

The system uses temporary producers to restore data, which means:
- Data is validated if you use `ValidatedPublisher`
- Invalid data is logged and skipped
- Widgets won't receive corrupted data

### 3. Handle Missing Data

Widgets should provide initial/default data:

```typescript
const initialData = {
  title: 'Default Title',
  content: 'Default content',
  markdown: false
};

<ParagraphWidget data={initialData} />
```

This ensures widgets display something even if no saved data exists.

### 4. Clear Data When Appropriate

```typescript
// When user resets dashboard
dashboard.resetToDefault();  // Clears mapStore data

// When user clears saved state
dashboard.clearSavedDashboard();  // Clears mapStore data
```

---

## Storage Size Considerations

### What's Stored

LocalStorage has a limit (typically 5-10MB per domain). Monitor usage:

```typescript
// Check storage size
const widgetData = localStorage.getItem('dashboard_widget_data');
const sizeKB = widgetData ? new Blob([widgetData]).size / 1024 : 0;
console.log(`Widget data size: ${sizeKB.toFixed(2)} KB`);
```

### Large Data Handling

If you have large datasets:

1. **Filter what gets saved:**
   ```typescript
   // In a custom save method
   const essentialData = {
     'paragraph-content': mapStore.getData('paragraph-content'),
     // Only save essential channels
   };
   ```

2. **Use compression** (advanced):
   ```typescript
   import pako from 'pako';
   const compressed = pako.deflate(JSON.stringify(data));
   ```

3. **Consider IndexedDB** for large datasets (not implemented yet)

---

## Data Persistence Lifecycle

### Complete Lifecycle:

```
1. Widget initializes → Creates consumer
         ↓
2. Producer publishes data → mapObjectStore updated
         ↓
3. User saves dashboard → Data captured to localStorage
         ↓
4. User closes/refreshes page
         ↓
5. Page loads → Dashboard initializes
         ↓
6. Storage restores data → mapObjectStore populated
         ↓
7. Widget consumer receives restored data
         ↓
8. Widget displays saved content ✅
```

---

## Testing

### Test Save/Restore Flow

1. **Submit an AI job** and wait for content to display
2. **Click "Save"** in dashboard controls
3. **Check console** for save logs
4. **Refresh the page**
5. **Check console** for restore logs
6. **Verify widget** still shows AI content

### Test Clear Flow

1. **Click "Clear"** in dashboard controls
2. **Check console** for clear logs
3. **Verify mapStore** is cleared (use debug panel)
4. **Verify localStorage** is empty

---

## Migration from v1.0.0 to v2.0.0

### Automatic Migration

When users load the dashboard:

```
1. Check version in localStorage
         ↓
2. If version is 1.0.0 (old)
         ↓
3. Clear old data (incompatible)
         ↓
4. User gets fresh dashboard
         ↓
5. New saves use v2.0.0 format
```

### Manual Migration (if needed)

```typescript
// Export old dashboard first
const oldData = localStorage.getItem('dashboard_widgets');

// Clear
dashboard.clearSavedDashboard();

// Re-add widgets
const widgets = JSON.parse(oldData);
widgets.forEach(w => dashboard.addWidget(w));

// Save (will use new format)
dashboard.save();
```

---

## API Reference

### DashboardStorage Methods

```typescript
// Save dashboard (includes widget data)
DashboardStorage.saveDashboard(widgets, config): boolean

// Load dashboard (restores widget data)
DashboardStorage.loadDashboard(): DashboardState | null

// Clear dashboard (clears widget data)
DashboardStorage.clearDashboard(): boolean

// Export dashboard (includes widget data)
DashboardStorage.exportDashboard(): string | null

// Import dashboard (restores widget data)
DashboardStorage.importDashboard(json): boolean
```

### DashboardState Interface

```typescript
interface DashboardState {
  widgets: Widget[];           // Widget configurations
  config: DashboardConfig;     // Grid configuration
  widgetData: WidgetDataSnapshot;  // mapObjectStore data ← NEW!
  version: string;             // Version (2.0.0)
}

interface WidgetDataSnapshot {
  [channelId: string]: any;    // Channel → Data mapping
}
```

---

## Summary

✅ **Widget data now persists** across page refreshes  
✅ **AI-generated content preserved** when saving dashboard  
✅ **Automatic save/restore** - no code changes needed  
✅ **Version tracking** - prevents incompatible data loading  
✅ **Console logging** - full visibility into save/restore process  
✅ **Clean up** - data cleared when dashboard is reset  

**Everything you need for persistent, dynamic widgets!** 🎉

---

## Related Documentation

- **MapStore Debug Panel**: `MAPSTORE_DEBUG_GUIDE.md`
- **Widget Bridge System**: `WIDGET_TYPE_SYSTEM.md`
- **Storage Implementation**: `src/lib/dashboard/utils/storage.ts`


# Widget Data Persistence Guide

## Overview

The dashboard now **automatically saves and restores widget data** from the mapObjectStore when saving to local storage. This means AI-generated content, user inputs, and any dynamic widget data persists across browser sessions.

---

## What Gets Saved?

### Before (Version 1.0.0)
```json
{
  "widgets": [
    {
      "id": "widget-1",
      "type": "paragraph",
      "data": {
        "title": "Static Title",
        "content": "Static content from code"
      }
    }
  ],
  "config": { ... }
}
```

**Problem:** Only static widget configuration was saved, not dynamic data from mapObjectStore.

### After (Version 2.0.0)
```json
{
  "widgets": [
    {
      "id": "widget-1",
      "type": "paragraph",
      "data": {
        "title": "Static Title",
        "content": "Static content"
      }
    }
  ],
  "config": { ... },
  "widgetData": {
    "paragraph-content": {
      "title": "AI Generated Title",
      "content": "This was generated by AI and persists!",
      "markdown": true
    },
    "table-data": {
      "headers": ["Name", "Value"],
      "rows": [...]
    }
  }
}
```

**Solution:** Widget data from all mapObjectStore channels is now saved and restored!

---

## How It Works

### Save Flow

```
User clicks "Save" or auto-save triggers
         ‚Üì
dashboard.save() called
         ‚Üì
DashboardStorage.saveDashboard()
         ‚Üì
mapStore.getAllData() ‚Üê Captures all channel data
         ‚Üì
Creates widgetData snapshot:
{
  "paragraph-content": {...},
  "table-data": {...},
  "metric-data": {...}
}
         ‚Üì
Saves to localStorage:
- WIDGETS (widget configuration)
- CONFIG (grid configuration)
- WIDGET_DATA (mapObjectStore data) ‚Üê NEW!
- VERSION (2.0.0)
```

### Load Flow

```
User opens dashboard
         ‚Üì
dashboard.initialize() called
         ‚Üì
DashboardStorage.loadDashboard()
         ‚Üì
Reads from localStorage:
- widgets
- config
- widgetData ‚Üê NEW!
         ‚Üì
restoreWidgetData() called
         ‚Üì
For each channel in widgetData:
  1. Create temporary producer
  2. Publish data to mapObjectStore
  3. Unregister temporary producer
         ‚Üì
Widgets subscribe and receive restored data
         ‚Üì
Dashboard displays with saved content!
```

---

## Example Scenario

### 1. User Submits AI Job

```
User clicks "Submit Job"
         ‚Üì
AI generates paragraph content
         ‚Üì
Bridge publishes to mapObjectStore:
  Channel: paragraph-content
  Data: { title: "AI Summary", content: "..." }
         ‚Üì
ParagraphWidget displays AI content
```

### 2. User Saves Dashboard

```
User clicks "Save" (or auto-save)
         ‚Üì
DashboardStorage captures:
  - Widget configurations
  - mapObjectStore data ‚Üê AI content captured!
         ‚Üì
Saved to localStorage
```

### 3. User Refreshes Page

```
Page loads
         ‚Üì
Dashboard initializes
         ‚Üì
Restores mapObjectStore data
         ‚Üì
ParagraphWidget receives AI content again
         ‚Üì
AI-generated content is still there! üéâ
```

---

## Console Output

### When Saving:

```
üíæ [DashboardStorage] Saving dashboard to localStorage...
   ‚úÖ Captured data for channel: paragraph-content
   ‚úÖ Captured data for channel: table-data
   ‚úÖ Captured data for channel: metric-data
   Total channels saved: 3
‚úÖ [DashboardStorage] Dashboard saved successfully
```

### When Loading:

```
üìÇ [DashboardStorage] Loading dashboard from localStorage...
   ‚úÖ Loaded 8 widgets
   ‚úÖ Loaded 3 widget data channels

üì§ [DashboardStorage] Restoring widget data to mapObjectStore...
   ‚úÖ Restored data for channel: paragraph-content
   ‚úÖ Restored data for channel: table-data
   ‚úÖ Restored data for channel: metric-data
‚úÖ [DashboardStorage] Widget data restoration complete
```

### When Clearing:

```
üßπ [DashboardStore] Clearing saved dashboard...
   Clearing mapObjectStore data...
‚úÖ [DashboardStore] Dashboard and widget data cleared from localStorage
```

---

## What Data is Saved?

All data currently in the mapObjectStore channels:

| Channel | Data Saved | Example |
|---------|------------|---------|
| `paragraph-content` | AI-generated paragraphs | `{title, content, markdown}` |
| `table-data` | Table rows and headers | `{headers, rows}` |
| `metric-data` | Metric values | `{label, value, change}` |
| `chart-data` | Chart datasets | `{datasets, labels}` |
| Custom channels | Any custom data | Whatever you publish |

**Only channels with data are saved** (undefined values are skipped).

---

## Version Upgrade

### Version Change: 1.0.0 ‚Üí 2.0.0

The storage version was bumped to `2.0.0` because the data structure changed to include `widgetData`.

**What happens to old saved dashboards?**

```
User has dashboard saved with v1.0.0
         ‚Üì
Loads page
         ‚Üì
Version mismatch detected
         ‚Üì
Old data is cleared (v1.0.0 incompatible)
         ‚Üì
User gets fresh dashboard
```

**Why clear old data?**
- v1.0.0 doesn't have `widgetData` field
- Prevents errors from incompatible structure
- Clean slate for new version

---

## Using the Feature

### Automatic (No Code Changes Needed)

If you're already using:
- `createWidgetConsumer()` in widgets
- `createJobWidgetBridge()` or `createWidgetPublisher()` for data
- Dashboard save functionality

**It just works!** Widget data is automatically saved and restored.

### Manual Data Snapshot

```typescript
import { mapStore } from '$lib/stores/mapObjectStore';

// Get current snapshot
const snapshot = mapStore.getAllData();

// Save manually
localStorage.setItem('my-widget-data', JSON.stringify(snapshot));

// Restore manually
const saved = JSON.parse(localStorage.getItem('my-widget-data'));
saved.forEach(item => {
  const producer = mapStore.registerProducer(item.typeId, 'restore');
  producer.publish(item.value);
  mapStore.unregister('restore');
});
```

---

## Debugging

### Check What's Being Saved

```typescript
// After saving, check localStorage
const widgetData = localStorage.getItem('dashboard_widget_data');
console.log('Saved widget data:', JSON.parse(widgetData));
```

### Verify Restoration

```typescript
// After loading, check mapStore
import { mapStore } from '$lib/stores/mapObjectStore';

// Use debug panel or:
console.table(mapStore.getAllData());
```

### Console Logs

Enable detailed logging by watching for these log messages:

**On Save:**
- `üíæ [DashboardStorage] Saving dashboard to localStorage...`
- `‚úÖ Captured data for channel: ...`

**On Load:**
- `üìÇ [DashboardStorage] Loading dashboard from localStorage...`
- `‚úÖ Restored data for channel: ...`

---

## Best Practices

### 1. Use Meaningful Channel IDs

```typescript
// Good
WidgetChannels.paragraphContent  // 'paragraph-content'
WidgetChannels.tableData         // 'table-data'

// Bad
'channel1'
'temp-data'
```

Meaningful IDs make it easier to debug what's saved.

### 2. Validate Data on Restore

The system uses temporary producers to restore data, which means:
- Data is validated if you use `ValidatedPublisher`
- Invalid data is logged and skipped
- Widgets won't receive corrupted data

### 3. Handle Missing Data

Widgets should provide initial/default data:

```typescript
const initialData = {
  title: 'Default Title',
  content: 'Default content',
  markdown: false
};

<ParagraphWidget data={initialData} />
```

This ensures widgets display something even if no saved data exists.

### 4. Clear Data When Appropriate

```typescript
// When user resets dashboard
dashboard.resetToDefault();  // Clears mapStore data

// When user clears saved state
dashboard.clearSavedDashboard();  // Clears mapStore data
```

---

## Storage Size Considerations

### What's Stored

LocalStorage has a limit (typically 5-10MB per domain). Monitor usage:

```typescript
// Check storage size
const widgetData = localStorage.getItem('dashboard_widget_data');
const sizeKB = widgetData ? new Blob([widgetData]).size / 1024 : 0;
console.log(`Widget data size: ${sizeKB.toFixed(2)} KB`);
```

### Large Data Handling

If you have large datasets:

1. **Filter what gets saved:**
   ```typescript
   // In a custom save method
   const essentialData = {
     'paragraph-content': mapStore.getData('paragraph-content'),
     // Only save essential channels
   };
   ```

2. **Use compression** (advanced):
   ```typescript
   import pako from 'pako';
   const compressed = pako.deflate(JSON.stringify(data));
   ```

3. **Consider IndexedDB** for large datasets (not implemented yet)

---

## Data Persistence Lifecycle

### Complete Lifecycle:

```
1. Widget initializes ‚Üí Creates consumer
         ‚Üì
2. Producer publishes data ‚Üí mapObjectStore updated
         ‚Üì
3. User saves dashboard ‚Üí Data captured to localStorage
         ‚Üì
4. User closes/refreshes page
         ‚Üì
5. Page loads ‚Üí Dashboard initializes
         ‚Üì
6. Storage restores data ‚Üí mapObjectStore populated
         ‚Üì
7. Widget consumer receives restored data
         ‚Üì
8. Widget displays saved content ‚úÖ
```

---

## Testing

### Test Save/Restore Flow

1. **Submit an AI job** and wait for content to display
2. **Click "Save"** in dashboard controls
3. **Check console** for save logs
4. **Refresh the page**
5. **Check console** for restore logs
6. **Verify widget** still shows AI content

### Test Clear Flow

1. **Click "Clear"** in dashboard controls
2. **Check console** for clear logs
3. **Verify mapStore** is cleared (use debug panel)
4. **Verify localStorage** is empty

---

## Migration from v1.0.0 to v2.0.0

### Automatic Migration

When users load the dashboard:

```
1. Check version in localStorage
         ‚Üì
2. If version is 1.0.0 (old)
         ‚Üì
3. Clear old data (incompatible)
         ‚Üì
4. User gets fresh dashboard
         ‚Üì
5. New saves use v2.0.0 format
```

### Manual Migration (if needed)

```typescript
// Export old dashboard first
const oldData = localStorage.getItem('dashboard_widgets');

// Clear
dashboard.clearSavedDashboard();

// Re-add widgets
const widgets = JSON.parse(oldData);
widgets.forEach(w => dashboard.addWidget(w));

// Save (will use new format)
dashboard.save();
```

---

## API Reference

### DashboardStorage Methods

```typescript
// Save dashboard (includes widget data)
DashboardStorage.saveDashboard(widgets, config): boolean

// Load dashboard (restores widget data)
DashboardStorage.loadDashboard(): DashboardState | null

// Clear dashboard (clears widget data)
DashboardStorage.clearDashboard(): boolean

// Export dashboard (includes widget data)
DashboardStorage.exportDashboard(): string | null

// Import dashboard (restores widget data)
DashboardStorage.importDashboard(json): boolean
```

### DashboardState Interface

```typescript
interface DashboardState {
  widgets: Widget[];           // Widget configurations
  config: DashboardConfig;     // Grid configuration
  widgetData: WidgetDataSnapshot;  // mapObjectStore data ‚Üê NEW!
  version: string;             // Version (2.0.0)
}

interface WidgetDataSnapshot {
  [channelId: string]: any;    // Channel ‚Üí Data mapping
}
```

---

## Summary

‚úÖ **Widget data now persists** across page refreshes  
‚úÖ **AI-generated content preserved** when saving dashboard  
‚úÖ **Automatic save/restore** - no code changes needed  
‚úÖ **Version tracking** - prevents incompatible data loading  
‚úÖ **Console logging** - full visibility into save/restore process  
‚úÖ **Clean up** - data cleared when dashboard is reset  

**Everything you need for persistent, dynamic widgets!** üéâ

---

## Related Documentation

- **MapStore Debug Panel**: `MAPSTORE_DEBUG_GUIDE.md`
- **Widget Bridge System**: `WIDGET_TYPE_SYSTEM.md`
- **Storage Implementation**: `src/lib/dashboard/utils/storage.ts`

